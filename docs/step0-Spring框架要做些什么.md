### 前言

要自己做一个东西出来，那就逃不掉这几个问题：

1. 我为什么需要它？（当前面对的业务问题是什么？）
2. 它的基本思路是什么？（它要以什么样的手段去解决问题？）
3. 未来它还可以去如何拓展？（实际实现中它的更多功能点。）

有了这些问题打底，才能在写的时候不丢掉方向。

#### Spring 之前

因为现在的活做得辛苦，所以才发明出新的工具，新的工具是为了干已经有的活；但是有了新工具提高了效率之后人们又敢去碰新的更高难度更复杂的活计了，就这样鸡生蛋蛋生鸡循环发展，不过那都是后话，与本主题无关啦。

在有了 Spring 框架之前，我们是怎么做 Web 开发的？

##### MVC 与 Servlet

待完成……

待完成……

### 总结一下，我们为什么要用 Spring

1. 开发者不再需要手动实例化对象。Spring 容器直接管理好了所有对象实例，直接依赖注入就行。这个直接注入有两个好处：
   1. 开发者用不着琢磨对象间的依赖关系，去从依赖链的开头开始手动 new 对象出来。更复杂的，它还以某种方式帮开发者解决了循环依赖问题。
   2. 许多实例（譬如只有方法的 ServiceImpl 实例）都是单例，框架自动帮我们复用了起来，减少了开销。
2. 可以用注解去简单地实现自定义 AOP，给方法做缓存，做限流，做访问权限控制，做日志等等。
3. Spring Event 功能，让我们除了 Command 之外多了一个令模块之间相互协作的方式，A 模块想要让 B、C、D 模块做事情不需要持有 B、C、D 的引用，也不需要直接调用它们的方法，广播事件就行了！这就解耦了不同的功能模块。
4. 至于依赖倒置这件事情……仅以我的经验来说，如果每次只是在 ServiceImpl 里面添加方法，然后在 Service 里添加接口，那工作量一点没少，复杂度一点没低。那么怎样才算是“符合依赖倒置原则且真正简化开发的设计“，一个可能的方向是要极大地精简 Service 里的接口，从而明确每个服务模块的边界，可以尝试用 ”Service 内的接口数量 / ServiceImpl 内实现的方法数量“ 这个简单的值来评价是否做到了封装，不过我现在真不懂，以后再讨论。

### 所以实现的时候我们将要关注什么

1. Spring 怎么去扫描与解析配置，怎么去做实例的初始化。
2. Bean 容器的管理。Spring 是如何处理实例之间的依赖的。
3. Spring Event 的实现。
4. 各种注解是如何工作的。

---

实际的 Spring 做到了更多更多，但是我们可能没有精力去关注：

1. Spring 对于 Restful API 开发的简化与封装。
2. Spring 对于数据库操作的封装，即 Spring Data JPA 的实现。
3. Spring 对于各种第三方框架（Hibernate、Mybatis、Redis、RabbitMQ）的兼容处理。
4. ……

